---
title: Introduction - Newton
date: 2022-04-14T13:00:00
tags: [processing]
description: Ouverture et prÃ©sentation du club, puis dÃ©couverte de processing avec simulation d'une boule suivant les lois du mouvement de newton.
image_url: https://res.cloudinary.com/dr844cxrp/image/upload/v1649958716/out_shooyn.gif
---

# {title}

Bienvenue dans le club Programation et Logique ðŸ¤—

## Nos objectifs

- DÃ©couvrir des languages de Programation
  - Python
  - Javascript
  - Java
- Des outils de dÃ©veloppement
  - Processing
  - P5.js
- Participer a des concours
  - [IOI](http://www.france-ioi.org/)
    - [AlgorÃ©a](https://www.algorea.org/main.html)
- Faire des activitÃ©es sur des sites pour s'amÃ©liorer en programmation:
  - [CodeWars](https://www.codewars.com/)
  - [Project Euler](https://projecteuler.net/)
  - [CodinGame](https://www.codingame.com/)
- Faire des sites web


## Session: **DÃ©couverte de processing**

 
Nous avons simulÃ© une boule affÃ©ctÃ©e par la gravitÃ© et autres forces en suivant les [Lois du mouvement de newton](https://fr.wikipedia.org/wiki/Lois_du_mouvement_de_Newton) sur [processing](https://processing.org/).

![Preview](https://res.cloudinary.com/dr844cxrp/image/upload/v1649958716/out_shooyn.gif)


### PremiÃ¨re loi: **InÃ¨rtie**
> Â« Tout corps persÃ©vÃ¨re dans l'Ã©tat de repos ou de mouvement uniforme en ligne droite dans lequel il se trouve, Ã  moins que quelque force n'agisse sur lui, et ne le contraigne Ã  changer d'Ã©tat. Â»
- L'inÃ©rtie est uniforme si aucune force est apliquÃ© Ã  l'objet.
- La sommes des force forces externes est ajoutÃ© a l'inertie.
### DeuxiÃ¨me loi: **dynamique de translation**
> Â« Les changements qui arrivent dans le mouvement sont proportionnels Ã  la force motrice ; et se font dans la ligne droite dans laquelle cette force a Ã©tÃ© imprimÃ©e. Â»
- La force nÃ©cesaire pour dÃ©placer un objet est proportionelle a sa masse:
  - la masse des forces externes est divisÃ©e pas la masse de l'objet
### TroisiÃ¨me loi: **action-rÃ©action**
> Â« L'action est toujours Ã©gale Ã  la rÃ©action ; c'est-Ã -dire que les actions de deux corps l'un sur l'autre sont toujours Ã©gales et de sens contraires. Â»
- Collisions: inversion de la force de l'objet


## Code:
```java
// ### Fichier principal avec setup et draw ###

// Nombre de cercles Ã  afficher
int OBJECT_CNT = 10;

// Force de la gravitÃ©
float GRAVITY = 0.2f;
// QuoÃ©fficient de rÃ©stitution des murs, a quel point ils rebondissent
float WALLS_RESTITUTION = 0.6f;

// Liste contenant tous les cercles
Object[] objects;


// Variables pour l'ajout de force par glissement
PVector start_drag; // Position du dÃ©but du glissement
boolean dragging = false; // En train de glisser?

public void setup() {
  size(600, 600);
  // Initialisation de la liste de cercles
  objects = new Object[OBJECT_CNT];
  for (int i = 0; i < objects.length; i++) {
    // valeurs alÃ©atoires   x            , y             , masse
    objects[i] = new Object(random(width), random(height), random(1, 10));
    // Toutes les balles commencent avec une force alÃ©atoire
    objects[i].applyForce(new PVector(random( -10, 10), random( -10, 10)));
  }
}

public void draw() {
  // RÃ©initialisation
  background(200);
  stroke(0); // Couleur des bordures
  fill(255); // Couleur de remplissage des formes
  strokeWeight(2); // Largeur des bordures

  // Boucle travÃ©rsant tous les objets
  for (int i = 0; i < objects.length; i++) {
    objects[i].update(); // Mets a jour tous les objets
    objects[i].show(); // les affiche
  }

  // affichage de la fleche de lissement
  if (dragging) {
    stroke(0, 200, 255 );
    fill(0, 200, 255);
    int startMarkerSize = 10;
    rect(start_drag.x - startMarkerSize/2, start_drag.y - startMarkerSize/2, startMarkerSize, startMarkerSize);
    line(start_drag.x, start_drag.y, mouseX, mouseY);
  }
}

// commencer a glisser quand le bouton de la souris est appuyÃ©
public void mousePressed() {
  start_drag = new PVector(mouseX, mouseY);
  dragging = true;
}

// arÃ©ter le glissement et appliquer la force
public void mouseReleased() {
  PVector force = new PVector(
    mouseX - start_drag.x,
    mouseY - start_drag.y
    ).div(2);

  for (int i = 0; i < objects.length; i++) {
    objects[i].applyForce(force);
  }

  // Plus de glissement
  start_drag = null;
  dragging = false;
}


// rÃ©initialisation des balles
public void keyPressed() {
  if (key == 'r') {
    println("reset");
    for (int i = 0; i < objects.length; i++) {
      objects[i].vel.mult(0);
    }
  }
}
```
```java
// Fichier avec la classe objet
public class Object {
  // position, vÃ©locitÃ©, accÃ©leration
  // L'accÃ©leration est rÃ©initialisÃ©e a chaque fois, elle correspond a la somme de toutes les forces appliquÃ©es sur l'objet.
  PVector pos, vel, acc;
  float mass;
  float radius;

  Object(float x, float y, float m) {
    // fonction Ã©xÃ©cutÃ©e quand l'objet est crÃ©e
    pos = new PVector(x, y);
    vel = new PVector(0, 0);
    acc = new PVector(0, 0);
    mass = m;
    radius = m * 10;
  }

  void applyForce(PVector force) {
    PVector f = PVector.div(force, mass);
    acc.add(f);
  }

  void update() {
    // On a joute la gravitÃ© a la velocitÃ©, ! pas divisÃ© par la masse !
    vel.y += GRAVITY;

    // On applique l'accÃ©leration a la vÃ©locitÃ©
    vel.add(acc);

    // On vÃ©rifie les colisions
    collide();

    // On applique la vÃ©locitÃ© a la position
    pos.add(vel);

    // On rÃ©initialise l'acceleration
    acc.mult(0);
  }

  // Verification des colisions avec les murs
  void collide() {
    float bottom = height - radius / 2;
    float right = width - radius / 2;
    float left = radius / 2;
    float top = radius / 2;

    if (pos.y >= bottom) {
      vel.y *= -WALLS_RESTITUTION;
      pos.y = bottom;
    } else if (pos.y <= top) {
      vel.y *= -WALLS_RESTITUTION;
      pos.y = top;
    } else if (pos.x >= right) {
      vel.x *= -WALLS_RESTITUTION;
      pos.x = right;
    } else if (pos.x <= left) {
      vel.x *= -WALLS_RESTITUTION;
      pos.x = left;
    }
  }

  void show() {
    ellipse(pos.x, pos.y, radius, radius);
  }
}
```

